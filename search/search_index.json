{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FCPM \u2014 Fluorescence Confocal Polarizing Microscopy","text":"<p>A Python library for simulating and reconstructing liquid crystal director fields from Fluorescence Confocal Polarizing Microscopy (FCPM) data.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simulation: Generate synthetic FCPM intensity images from known director fields</li> <li>Reconstruction: Recover director fields from FCPM measurements using Q-tensor methods</li> <li>Sign Optimization: Six approaches for resolving n/-n ambiguity (graph cuts, simulated annealing, hierarchical, belief propagation, layer propagation, combined)</li> <li>Frank Energy: Anisotropic elastic energy decomposition (splay, twist, bend)</li> <li>Analysis: Comprehensive metrics including sign accuracy, angular error, spatial distributions</li> <li>Visualization: Director field plots, error maps, FCPM intensities</li> <li>I/O: NPZ, HDF5, MATLAB, TIFF, VTK formats</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import fcpm\n\n# Create a cholesteric liquid crystal\ndirector = fcpm.create_cholesteric_director(shape=(64, 64, 32), pitch=8.0)\n\n# Simulate FCPM measurements\nI_fcpm = fcpm.simulate_fcpm(director)\n\n# Reconstruct and fix signs\ndirector_recon, info = fcpm.reconstruct(I_fcpm, fix_signs=True)\n\n# Evaluate\nmetrics = fcpm.summary_metrics(director_recon, director)\nprint(f\"Angular error: {metrics['angular_error_mean_deg']:.2f} degrees\")\n</code></pre>"},{"location":"#version","title":"Version","text":"<p>Current version: 2.0.0</p> <p>See the Installation guide to get started.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#sign-optimization-comparison","title":"Sign Optimization Comparison","text":"<p>The validation script <code>examples/03_soliton_validation.py</code> benchmarks all six sign-optimization methods on synthetic cholesteric fields with controlled sign scrambling (50% random flips).</p>"},{"location":"benchmarks/#running-the-benchmark","title":"Running the Benchmark","text":"<pre><code># Synthetic data (no input file needed)\npython examples/03_soliton_validation.py\n\n# With real LCSim data\npython examples/03_soliton_validation.py --input data/CF1.npz --output results/\n\n# With verbose output\npython examples/03_soliton_validation.py -v\n</code></pre>"},{"location":"benchmarks/#typical-results-64x64x32-cholesteric-pitch8","title":"Typical Results (64x64x32 Cholesteric, pitch=8)","text":"Method Energy Reduction Sign Accuracy Energy Recovery Time Combined (V1) ~85-95% ~0.85-0.95 ~85-95% &lt;0.5s LayerPropagation ~85-95% ~0.85-0.95 ~85-95% &lt;0.5s GraphCuts ~95-100% ~0.95-1.00 ~95-100% &lt;1s SimulatedAnnealing ~90-98% ~0.90-0.98 ~90-98% 1-10s Hierarchical ~90-98% ~0.90-0.98 ~90-98% &lt;1s BeliefPropagation ~80-95% ~0.80-0.95 ~80-95% &lt;1s <p>Note</p> <p>Results depend on the specific structure, size, and random seed. Graph Cuts achieves the global optimum for the pairwise energy formulation.</p>"},{"location":"benchmarks/#metrics-explained","title":"Metrics Explained","text":"<ul> <li>Energy Reduction: Percentage decrease in gradient energy after optimization</li> <li>Sign Accuracy: Fraction of voxels whose sign matches the ground truth</li> <li>Energy Recovery: How much of the scrambling-induced energy increase is recovered   (100% = perfect recovery to ground-truth energy)</li> <li>Time: Wall-clock time on a single CPU core</li> </ul>"},{"location":"benchmarks/#noise-sensitivity","title":"Noise Sensitivity","text":"<p>The validation notebook (<code>examples/03_soliton_validation.ipynb</code>) includes a noise sensitivity study that tests all methods at different noise levels (1%, 3%, 5%, 10%). Graph Cuts and Hierarchical methods maintain the highest accuracy under noise.</p>"},{"location":"benchmarks/#numba-acceleration","title":"Numba Acceleration","text":"<p>When <code>numba</code> is installed (<code>pip install numba</code> or <code>uv sync --extra perf</code>), the Simulated Annealing optimizer uses JIT-compiled kernels for the Metropolis sweep, providing significant speedup:</p> <pre><code>from fcpm.reconstruction.optimizers._numba_kernels import NUMBA_AVAILABLE\nprint(f\"Numba available: {NUMBA_AVAILABLE}\")\n</code></pre> <p>The first call incurs a compilation overhead; subsequent calls use cached machine code.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> <li>NumPy &gt;= 1.24.0</li> <li>SciPy &gt;= 1.10.0</li> <li>Matplotlib &gt;= 3.7.0</li> </ul>"},{"location":"installation/#using-uv-recommended","title":"Using UV (Recommended)","text":"<pre><code>git clone https://github.com/your-org/FCPM-Simulation.git\ncd FCPM-Simulation\n\nuv sync                        # core dependencies\nuv sync --extra full           # + pymaxflow, tifffile, h5py\nuv sync --extra dev            # + pytest, ruff\nuv sync --extra perf           # + numba acceleration\n</code></pre>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code>git clone https://github.com/your-org/FCPM-Simulation.git\ncd FCPM-Simulation\n\npip install -e .               # core dependencies\npip install -e \".[full]\"       # + optional extras\npip install -e \".[dev]\"        # + development tools\npip install -e \".[perf]\"       # + numba acceleration\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"Extra Packages Purpose <code>full</code> pymaxflow, tifffile, h5py Graph cuts optimizer, TIFF I/O, HDF5 I/O <code>dev</code> pytest, pytest-cov, ruff Testing and linting <code>perf</code> numba JIT-compiled simulated annealing kernels <code>docs</code> mkdocs, mkdocs-material, mkdocstrings Documentation site"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import fcpm\nprint(fcpm.__version__)  # Should print 2.0.0\n</code></pre>"},{"location":"preprocessing/","title":"Preprocessing","text":""},{"location":"preprocessing/#cropping","title":"Cropping","text":"<pre><code>import fcpm\n\n# Crop to specific region\ndirector_crop = fcpm.crop_director(director,\n    y_range=(100, 200), x_range=(100, 200), z_range=(10, 30))\n\n# Crop from center\ndirector_crop = fcpm.crop_director_center(director, size=(64, 64, 32))\n\n# Same for FCPM data\nI_crop = fcpm.crop_fcpm_center(I_fcpm, size=(64, 64, 32))\n</code></pre>"},{"location":"preprocessing/#filtering","title":"Filtering","text":"<pre><code># Gaussian smoothing\nI_smooth = fcpm.gaussian_filter_fcpm(I_fcpm, sigma=1.0)\n\n# Median filter (salt-and-pepper noise)\nI_filtered = fcpm.median_filter_fcpm(I_fcpm, size=3)\n\n# Background removal\nI_clean = fcpm.remove_background_fcpm(I_fcpm, method='percentile')\n\n# Normalization\nI_norm = fcpm.normalize_fcpm(I_fcpm, method='global')\n</code></pre>"},{"location":"preprocessing/#adding-noise","title":"Adding Noise","text":"<p>For simulation testing:</p> <pre><code># Realistic mixed noise\nI_noisy = fcpm.add_fcpm_realistic_noise(\n    I_fcpm, noise_model='mixed', gaussian_sigma=0.03, seed=42)\n\n# Individual types\nI_noisy = fcpm.add_gaussian_noise(I_fcpm, sigma=0.05)\nI_noisy = fcpm.add_poisson_noise(I_fcpm, scale=100)\n</code></pre>"},{"location":"preprocessing/#subsampling","title":"Subsampling","text":"<pre><code>director_sub = fcpm.subsample_director(director, factor=2)\nI_sub = fcpm.subsample_fcpm(I_fcpm, factor=2)\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#workflow-1-simulation-reconstruction","title":"Workflow 1: Simulation + Reconstruction","text":"<p>Use this when you have a known director field and want to test reconstruction.</p> <pre><code>import fcpm\n\nconfig = fcpm.WorkflowConfig(\n    crop_size=(64, 64, 32),\n    noise_level=0.03,\n    noise_model='mixed',\n    fix_signs=True,\n    verbose=True,\n)\n\nresults = fcpm.run_simulation_reconstruction(\n    director_source='path/to/director.npz',\n    output_dir='output/',\n    config=config,\n)\n\nprint(f\"Angular error: {results.metrics['angular_error_mean_deg']:.2f} degrees\")\n</code></pre>"},{"location":"quickstart/#workflow-2-fcpm-reconstruction","title":"Workflow 2: FCPM Reconstruction","text":"<p>Use this when you have experimental FCPM data.</p> <pre><code>import fcpm\n\nconfig = fcpm.WorkflowConfig(\n    crop_size=(64, 64, 32),\n    filter_sigma=0.5,\n    fix_signs=True,\n    verbose=True,\n)\n\nresults = fcpm.run_reconstruction(\n    fcpm_source='path/to/fcpm_data.npz',\n    output_dir='output/',\n    config=config,\n)\n</code></pre>"},{"location":"quickstart/#step-by-step","title":"Step-by-Step","text":"<pre><code>import fcpm\n\n# 1. Create or load director\ndirector = fcpm.create_cholesteric_director(shape=(64, 64, 32), pitch=8.0)\n\n# 2. Simulate FCPM\nI_fcpm = fcpm.simulate_fcpm(director)\n\n# 3. Add noise\nI_noisy = fcpm.add_fcpm_realistic_noise(I_fcpm, gaussian_sigma=0.03, seed=42)\nI_noisy = fcpm.normalize_fcpm(I_noisy)\n\n# 4. Reconstruct\ndirector_recon, info = fcpm.reconstruct(I_noisy, fix_signs=True)\n\n# 5. Evaluate\nmetrics = fcpm.summary_metrics(director_recon, director)\nprint(f\"Mean angular error: {metrics['angular_error_mean_deg']:.2f} degrees\")\n</code></pre>"},{"location":"references/","title":"References","text":"<p>See the full list of scientific references in REFERENCES.md.</p>"},{"location":"references/#key-papers","title":"Key Papers","text":""},{"location":"references/#fcpm-technique","title":"FCPM Technique","text":"<ul> <li>Smalyukh, I.I., Shiyanovskii, S.V., &amp; Lavrentovich, O.D. (2001).   Three-dimensional imaging of orientational order by fluorescence confocal polarizing microscopy.   Chemical Physics Letters, 336(1-2), 88-96.</li> </ul>"},{"location":"references/#liquid-crystal-physics","title":"Liquid Crystal Physics","text":"<ul> <li>de Gennes, P.G. &amp; Prost, J. (1993).   The Physics of Liquid Crystals (2nd ed.). Oxford University Press.</li> </ul>"},{"location":"references/#sign-optimization-algorithms","title":"Sign Optimization Algorithms","text":"<ul> <li> <p>Boykov, Y. &amp; Kolmogorov, V. (2004).   An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision.   IEEE TPAMI, 26(9), 1124-1137. (Graph Cuts)</p> </li> <li> <p>Kirkpatrick, S., Gelatt, C.D., &amp; Vecchi, M.P. (1983).   Optimization by simulated annealing. Science, 220(4598), 671-680. (Simulated Annealing)</p> </li> </ul>"},{"location":"references/#solitons","title":"Solitons","text":"<ul> <li>Ackerman, P.J. &amp; Smalyukh, I.I. (2017).   Diversity of knot solitons in liquid crystals manifested by linking of preimages in torons and hopfions.   Physical Review X, 7(1), 011006.</li> </ul>"},{"location":"sign_optimization/","title":"Sign Optimization","text":""},{"location":"sign_optimization/#the-sign-ambiguity-problem","title":"The Sign Ambiguity Problem","text":"<p>In nematic liquid crystals, the director n and -n are physically equivalent. When reconstructing from FCPM data, each voxel's sign is determined independently, leading to inconsistent sign assignments that create artificial discontinuities.</p> <p>Sign optimization resolves this by minimizing the elastic (gradient) energy:</p> <p>$$E = \\frac{K}{2} \\int |\\nabla \\mathbf{n}|^2 \\, dV$$</p>"},{"location":"sign_optimization/#using-the-optimizers","title":"Using the Optimizers","text":"<p>All optimizers follow the same interface:</p> <pre><code>import fcpm\n\ndirector = fcpm.load_director('reconstructed.npz')\n\n# Pick an optimizer\noptimizer = fcpm.GraphCutsOptimizer()\nresult = optimizer.optimize(director, verbose=True)\n\n# Result contains everything\nprint(f\"Energy: {result.initial_energy:.1f} -&gt; {result.final_energy:.1f}\")\nprint(f\"Reduction: {result.energy_reduction_pct:.1f}%\")\ndirector_fixed = result.director\n</code></pre>"},{"location":"sign_optimization/#available-methods","title":"Available Methods","text":""},{"location":"sign_optimization/#combined-v1","title":"Combined (V1)","text":"<p>The original approach: chain propagation followed by iterative local flips. Fast and reliable baseline.</p> <pre><code>optimizer = fcpm.CombinedOptimizer()\n</code></pre>"},{"location":"sign_optimization/#layer-propagation","title":"Layer Propagation","text":"<p>Propagates sign consistency layer-by-layer along z, then refines iteratively. Good for structures with strong z-axis ordering.</p> <pre><code>optimizer = fcpm.LayerPropagationOptimizer()\n</code></pre>"},{"location":"sign_optimization/#graph-cuts","title":"Graph Cuts","text":"<p>Formulates sign optimization as a binary labeling problem and solves via min-cut/max-flow. Achieves the global optimum for the pairwise energy.</p> <pre><code>optimizer = fcpm.GraphCutsOptimizer()\n# Requires pymaxflow (pip install pymaxflow), falls back to NetworkX\n</code></pre>"},{"location":"sign_optimization/#simulated-annealing","title":"Simulated Annealing","text":"<p>Metropolis-Hastings with adaptive temperature schedule and optional Wolff cluster moves. Can escape local minima but requires more time.</p> <pre><code>optimizer = fcpm.SimulatedAnnealingOptimizer(\n    fcpm.SimulatedAnnealingConfig(\n        max_iterations=10000,\n        initial_temperature=5.0,\n        seed=42,\n    )\n)\n</code></pre>"},{"location":"sign_optimization/#hierarchical","title":"Hierarchical","text":"<p>Multi-scale coarse-to-fine approach. Coarsens the volume using Q-tensor averaging, optimizes at coarse scale, then refines progressively.</p> <pre><code>optimizer = fcpm.HierarchicalOptimizer()\n</code></pre>"},{"location":"sign_optimization/#belief-propagation","title":"Belief Propagation","text":"<p>Message passing on a factor graph. Experimental \u2014 may not converge on all structures.</p> <pre><code>optimizer = fcpm.BeliefPropagationOptimizer(\n    fcpm.BeliefPropagationConfig(max_iterations=30)\n)\n</code></pre>"},{"location":"sign_optimization/#comparison","title":"Comparison","text":"Method Accuracy Speed Notes Combined Good Fast Reliable baseline LayerPropagation Good Fast Best for layered structures GraphCuts Best Medium Global optimum for binary energy SimulatedAnnealing Very Good Slow Can escape local minima Hierarchical Very Good Medium Good speed/accuracy balance BeliefPropagation Variable Medium Experimental"},{"location":"sign_optimization/#frank-energy-analysis","title":"Frank Energy Analysis","text":"<p>For detailed energy analysis with anisotropic elastic constants:</p> <pre><code>from fcpm import FrankConstants, compute_frank_energy_anisotropic\n\nfrank = FrankConstants(K1=10.3, K2=7.4, K3=16.48)  # 5CB constants (pN)\nenergy = compute_frank_energy_anisotropic(director.to_array(), frank)\n\nprint(f\"Splay (K1): {energy['splay_integrated']:.2f}\")\nprint(f\"Twist (K2): {energy['twist_integrated']:.2f}\")\nprint(f\"Bend  (K3): {energy['bend_integrated']:.2f}\")\nprint(f\"Total:      {energy['total_integrated']:.2f}\")\n</code></pre>"},{"location":"visualization/","title":"Visualization","text":""},{"location":"visualization/#director-field-plots","title":"Director Field Plots","text":"<pre><code>import matplotlib.pyplot as plt\nimport fcpm\n\n# Quiver plot at a z-slice\nfig, ax = plt.subplots()\nfcpm.plot_director_slice(director, z_idx=16, step=2, ax=ax)\nplt.show()\n\n# RGB orientation map\nfig = fcpm.plot_director_rgb(director, z_idx=16)\nplt.show()\n\n# Streamlines\nfig = fcpm.plot_director_streamlines(director, z_idx=16)\nplt.show()\n</code></pre>"},{"location":"visualization/#fcpm-intensities","title":"FCPM Intensities","text":"<pre><code>fig = fcpm.plot_fcpm_intensities(I_fcpm, z_idx=16)\nplt.show()\n</code></pre>"},{"location":"visualization/#comparison-and-error-maps","title":"Comparison and Error Maps","text":"<pre><code># Side-by-side comparison\nfig = fcpm.compare_directors(director_gt, director_recon, z_idx=16)\nplt.show()\n\n# Angular error map\nfig, ax = plt.subplots()\nfcpm.plot_error_map(director_recon, director_gt, z_idx=16, ax=ax)\nplt.show()\n\n# Error histogram\nfig = fcpm.plot_error_histogram(director_recon, director_gt)\nplt.show()\n\n# Error by depth\nfig = fcpm.plot_error_by_depth(director_recon, director_gt)\nplt.show()\n</code></pre>"},{"location":"visualization/#q-tensor-visualization","title":"Q-tensor Visualization","text":"<pre><code>fig = fcpm.plot_qtensor_components(Q, z_idx=16)\nplt.show()\n\nfig = fcpm.plot_order_parameter(Q, z_idx=16)\nplt.show()\n</code></pre>"},{"location":"visualization/#3d-visualization","title":"3D Visualization","text":"<pre><code># Matplotlib 3D (no extra dependencies)\nfcpm.visualize_3d_matplotlib(director, subsample=4)\n\n# Export for ParaView\nfcpm.export_for_paraview(director, 'output.vtk')\n\n# TopoVec (if available)\nif fcpm.check_topovec_available():\n    fcpm.visualize_topovec(director)\n</code></pre>"},{"location":"workflows/","title":"Workflows","text":"<p>The library provides two high-level workflow functions that handle the full pipeline.</p>"},{"location":"workflows/#simulation-reconstruction","title":"Simulation + Reconstruction","text":"<p>When you have a known director field (ground truth):</p> <pre><code>import fcpm\n\nconfig = fcpm.WorkflowConfig(\n    crop_size=(64, 64, 32),\n    noise_level=0.03,\n    noise_model='mixed',    # 'gaussian', 'poisson', or 'mixed'\n    noise_seed=42,\n    fix_signs=True,\n    save_plots=True,\n    save_data=True,\n    verbose=True,\n)\n\nresults = fcpm.run_simulation_reconstruction(\n    director_source='director.npz',\n    output_dir='output/',\n    config=config,\n)\n</code></pre>"},{"location":"workflows/#fcpm-reconstruction","title":"FCPM Reconstruction","text":"<p>When you have experimental FCPM data (no ground truth):</p> <pre><code>results = fcpm.run_reconstruction(\n    fcpm_source='fcpm_data.npz',\n    output_dir='output/',\n    config=config,\n)\n</code></pre>"},{"location":"workflows/#output-structure","title":"Output Structure","text":"<pre><code>output/\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 director_reconstructed.npz\n\u2502   \u251c\u2500\u2500 director_ground_truth.npz   # simulation only\n\u2502   \u251c\u2500\u2500 qtensor.npz\n\u2502   \u2514\u2500\u2500 fcpm_input.npz\n\u251c\u2500\u2500 plots/\n\u2502   \u251c\u2500\u2500 director_recon_z*.png\n\u2502   \u251c\u2500\u2500 comparison_z*.png           # simulation only\n\u2502   \u251c\u2500\u2500 error_map_z*.png            # simulation only\n\u2502   \u2514\u2500\u2500 error_histogram.png         # simulation only\n\u251c\u2500\u2500 summary.json\n\u2514\u2500\u2500 summary.txt\n</code></pre>"},{"location":"workflows/#configuration-reference","title":"Configuration Reference","text":""},{"location":"workflows/#fcpm.workflows.WorkflowConfig","title":"<code>fcpm.workflows.WorkflowConfig</code>  <code>dataclass</code>","text":"<p>Configuration for FCPM workflows.</p>"},{"location":"api/core/","title":"Core API","text":""},{"location":"api/core/#directorfield","title":"DirectorField","text":""},{"location":"api/core/#fcpm.core.DirectorField","title":"<code>fcpm.core.DirectorField</code>  <code>dataclass</code>","text":"<p>Represents a 3D director field for liquid crystal systems.</p> <p>The director n = (nx, ny, nz) is a unit vector field defined on a 3D grid. Due to nematic symmetry, n and -n represent the same physical state.</p> <p>Attributes:</p> Name Type Description <code>nx</code> <code>ndarray</code> <p>x-component of director field, shape (ny, nx, nz)</p> <code>ny</code> <code>ndarray</code> <p>y-component of director field, shape (ny, nx, nz)</p> <code>nz</code> <code>ndarray</code> <p>z-component of director field, shape (ny, nx, nz)</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Optional dictionary for additional information</p> Note <p>Array indexing convention: (y_index, x_index, z_index) to match typical image conventions where first axis is vertical (y).</p>"},{"location":"api/core/#fcpm.core.DirectorField.shape","title":"<code>shape: Tuple[int, int, int]</code>  <code>property</code>","text":"<p>Return the shape of the director field (ny, nx, nz).</p>"},{"location":"api/core/#fcpm.core.DirectorField.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Return total number of voxels.</p>"},{"location":"api/core/#fcpm.core.DirectorField.ndim","title":"<code>ndim: int</code>  <code>property</code>","text":"<p>Return number of dimensions (always 3).</p>"},{"location":"api/core/#fcpm.core.DirectorField.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate and convert arrays to correct dtype.</p>"},{"location":"api/core/#fcpm.core.DirectorField.magnitude","title":"<code>magnitude() -&gt; np.ndarray</code>","text":"<p>Compute the magnitude |n| at each point.</p> <p>For a properly normalized director field, this should be 1.0 everywhere.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of magnitudes with same shape as components.</p>"},{"location":"api/core/#fcpm.core.DirectorField.normalize","title":"<code>normalize(inplace: bool = False) -&gt; 'DirectorField'</code>","text":"<p>Normalize the director field to unit length.</p> <p>Parameters:</p> Name Type Description Default <code>inplace</code> <code>bool</code> <p>If True, modify this field. If False, return new field.</p> <code>False</code> <p>Returns:</p> Type Description <code>'DirectorField'</code> <p>Normalized DirectorField (self if inplace=True).</p>"},{"location":"api/core/#fcpm.core.DirectorField.is_normalized","title":"<code>is_normalized(tol: float = 1e-06) -&gt; bool</code>","text":"<p>Check if the director field is normalized to unit length.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance for deviation from unit length.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if |n| \u2248 1 everywhere within tolerance.</p>"},{"location":"api/core/#fcpm.core.DirectorField.to_array","title":"<code>to_array() -&gt; np.ndarray</code>","text":"<p>Convert to a 4D array with shape (ny, nx, nz, 3).</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>4D numpy array with components stacked along last axis.</p>"},{"location":"api/core/#fcpm.core.DirectorField.from_array","title":"<code>from_array(arr: np.ndarray, metadata: Optional[Dict[str, Any]] = None) -&gt; 'DirectorField'</code>  <code>classmethod</code>","text":"<p>Create DirectorField from a 4D array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>Array with shape (..., 3) where last axis is (nx, ny, nz).</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <p>Returns:</p> Type Description <code>'DirectorField'</code> <p>New DirectorField instance.</p>"},{"location":"api/core/#fcpm.core.DirectorField.flip_signs","title":"<code>flip_signs(mask: np.ndarray) -&gt; 'DirectorField'</code>","text":"<p>Flip the sign of director at specified locations.</p> <p>Due to nematic symmetry (n \u2261 -n), this doesn't change the physics. Useful for ensuring consistent orientation across the field.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>Boolean array where True indicates flip locations.</p> required <p>Returns:</p> Type Description <code>'DirectorField'</code> <p>New DirectorField with flipped signs.</p>"},{"location":"api/core/#fcpm.core.DirectorField.slice_z","title":"<code>slice_z(z_idx: int) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]</code>","text":"<p>Extract a z-slice of the director field.</p> <p>Parameters:</p> Name Type Description Default <code>z_idx</code> <code>int</code> <p>Index of z-slice to extract.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray]</code> <p>Tuple of (nx, ny, nz) 2D arrays for the slice.</p>"},{"location":"api/core/#fcpm.core.DirectorField.copy","title":"<code>copy() -&gt; 'DirectorField'</code>","text":"<p>Create a deep copy of this director field.</p>"},{"location":"api/core/#qtensor","title":"QTensor","text":""},{"location":"api/core/#fcpm.core.QTensor","title":"<code>fcpm.core.QTensor</code>  <code>dataclass</code>","text":"<p>Represents a 3D Q-tensor field for liquid crystal systems.</p> <p>The Q-tensor is a symmetric, traceless 3x3 tensor at each point. Due to symmetry and tracelessness, only 5 independent components exist: - Q_xx, Q_yy (Q_zz = -Q_xx - Q_yy from tracelessness) - Q_xy = Q_yx - Q_xz = Q_zx - Q_yz = Q_zy</p> <p>Attributes:</p> Name Type Description <code>Q_xx</code> <code>ndarray</code> <p>xx-component, shape (ny, nx, nz)</p> <code>Q_yy</code> <code>ndarray</code> <p>yy-component, shape (ny, nx, nz)</p> <code>Q_xy</code> <code>ndarray</code> <p>xy-component, shape (ny, nx, nz)</p> <code>Q_xz</code> <code>ndarray</code> <p>xz-component, shape (ny, nx, nz)</p> <code>Q_yz</code> <code>ndarray</code> <p>yz-component, shape (ny, nx, nz)</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Optional dictionary for additional information</p> Note <p>Q_zz is not stored but computed as Q_zz = -Q_xx - Q_yy.</p>"},{"location":"api/core/#fcpm.core.QTensor.Q_zz","title":"<code>Q_zz: np.ndarray</code>  <code>property</code>","text":"<p>Compute Q_zz from tracelessness: Q_zz = -Q_xx - Q_yy.</p>"},{"location":"api/core/#fcpm.core.QTensor.shape","title":"<code>shape: Tuple[int, int, int]</code>  <code>property</code>","text":"<p>Return the shape of the Q-tensor field (ny, nx, nz).</p>"},{"location":"api/core/#fcpm.core.QTensor.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Return total number of voxels.</p>"},{"location":"api/core/#fcpm.core.QTensor.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate and convert arrays to correct dtype.</p>"},{"location":"api/core/#fcpm.core.QTensor.copy","title":"<code>copy() -&gt; 'QTensor'</code>","text":"<p>Create a deep copy of this Q-tensor field.</p>"},{"location":"api/core/#fcpm.core.QTensor.frobenius_norm","title":"<code>frobenius_norm() -&gt; np.ndarray</code>","text":"<p>Compute the Frobenius norm of Q at each point.</p> <p>||Q||_F = sqrt(Tr(Q\u00b2))</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Frobenius norm field.</p>"},{"location":"api/core/#fcpm.core.QTensor.scalar_order_parameter","title":"<code>scalar_order_parameter() -&gt; np.ndarray</code>","text":"<p>Compute the scalar order parameter S from the Q-tensor.</p> <p>The largest eigenvalue of Q is \u03bb_max = 2S/3. This method uses the Frobenius norm for efficiency: S = sqrt(3/2 * Tr(Q\u00b2))</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Scalar order parameter field S(r).</p>"},{"location":"api/core/#fcpm.core.QTensor.to_director","title":"<code>to_director() -&gt; DirectorField</code>","text":"<p>Extract the director field from Q-tensor via eigendecomposition.</p> <p>The director is the eigenvector corresponding to the largest eigenvalue. Note: Due to Q(n) = Q(-n), the sign of the director is arbitrary.</p> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField extracted from Q-tensor.</p>"},{"location":"api/core/#fcpm.core.QTensor.to_director_vectorized","title":"<code>to_director_vectorized() -&gt; DirectorField</code>","text":"<p>Extract director field using vectorized eigendecomposition.</p> <p>Faster than to_director() for large fields.</p> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField extracted from Q-tensor.</p>"},{"location":"api/core/#fcpm.core.QTensor.to_matrices","title":"<code>to_matrices() -&gt; np.ndarray</code>","text":"<p>Get all Q-tensor matrices as a 5D array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (ny, nx, nz, 3, 3).</p>"},{"location":"api/core/#fcpm.core.QTensor.to_matrix","title":"<code>to_matrix(y: int, x: int, z: int) -&gt; np.ndarray</code>","text":"<p>Get the full 3x3 Q-tensor matrix at a specific point.</p> <p>Parameters:</p> Name Type Description Default <code>y, x, z</code> <p>Voxel indices.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 symmetric traceless matrix.</p>"},{"location":"api/core/#fcpmsimulator","title":"FCPMSimulator","text":""},{"location":"api/core/#fcpm.core.FCPMSimulator","title":"<code>fcpm.core.FCPMSimulator</code>","text":"<p>High-level FCPM simulation interface.</p> <p>Provides a convenient object-oriented interface for simulating FCPM measurements with various options.</p> <p>Attributes:</p> Name Type Description <code>director</code> <p>The director field to simulate.</p> <code>angles</code> <p>Polarization angles used.</p> <code>noise_type</code> <p>Type of noise ('gaussian', 'poisson', or None).</p> <code>noise_level</code> <p>Noise magnitude.</p>"},{"location":"api/core/#fcpm.core.FCPMSimulator.intensities","title":"<code>intensities: Optional[Dict[float, np.ndarray]]</code>  <code>property</code>","text":"<p>Return last simulated intensities.</p>"},{"location":"api/core/#fcpm.core.FCPMSimulator.__init__","title":"<code>__init__(director: DirectorField, angles: Optional[List[float]] = None, noise_type: Optional[str] = None, noise_level: float = 0.05)</code>","text":"<p>Initialize FCPM simulator.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to simulate.</p> required <code>angles</code> <code>Optional[List[float]]</code> <p>Polarization angles in radians.</p> <code>None</code> <code>noise_type</code> <code>Optional[str]</code> <p>'gaussian', 'poisson', or None.</p> <code>None</code> <code>noise_level</code> <code>float</code> <p>Noise magnitude (std for Gaussian, photon count for Poisson).</p> <code>0.05</code>"},{"location":"api/core/#fcpm.core.FCPMSimulator.simulate","title":"<code>simulate(seed: Optional[int] = None) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Run FCPM simulation.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>Optional[int]</code> <p>Random seed for noise generation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary of simulated FCPM intensities.</p>"},{"location":"api/core/#fcpm.core.FCPMSimulator.to_array","title":"<code>to_array() -&gt; np.ndarray</code>","text":"<p>Stack intensities into a 4D array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (n_angles, ny, nx, nz).</p>"},{"location":"api/core/#director-creation-functions","title":"Director Creation Functions","text":""},{"location":"api/core/#fcpm.core.create_uniform_director","title":"<code>fcpm.core.create_uniform_director(shape: Tuple[int, int, int], direction: Tuple[float, float, float] = (0, 0, 1)) -&gt; DirectorField</code>","text":"<p>Create a uniform director field pointing in a fixed direction.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Tuple[int, int, int]</code> <p>Shape of the field (ny, nx, nz).</p> required <code>direction</code> <code>Tuple[float, float, float]</code> <p>Direction vector (will be normalized).</p> <code>(0, 0, 1)</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField with uniform orientation.</p>"},{"location":"api/core/#fcpm.core.create_cholesteric_director","title":"<code>fcpm.core.create_cholesteric_director(shape: Tuple[int, int, int], pitch: float = 10.0, axis: str = 'z') -&gt; DirectorField</code>","text":"<p>Create a cholesteric (twisted nematic) director field.</p> <p>The director rotates helically along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Tuple[int, int, int]</code> <p>Shape of the field (ny, nx, nz).</p> required <code>pitch</code> <code>float</code> <p>Helical pitch (full 360\u00b0 rotation distance in grid units).</p> <code>10.0</code> <code>axis</code> <code>str</code> <p>Helix axis ('x', 'y', or 'z').</p> <code>'z'</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField with cholesteric structure.</p>"},{"location":"api/core/#fcpm.core.create_radial_director","title":"<code>fcpm.core.create_radial_director(shape: Tuple[int, int, int], center: Optional[Tuple[float, float, float]] = None) -&gt; DirectorField</code>","text":"<p>Create a radial (hedgehog) director field.</p> <p>Director points radially outward from a center point.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Tuple[int, int, int]</code> <p>Shape of the field (ny, nx, nz).</p> required <code>center</code> <code>Optional[Tuple[float, float, float]]</code> <p>Center point (y, x, z). If None, uses grid center.</p> <code>None</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField with radial structure.</p>"},{"location":"api/core/#simulation-functions","title":"Simulation Functions","text":""},{"location":"api/core/#fcpm.core.simulate_fcpm","title":"<code>fcpm.core.simulate_fcpm(director: DirectorField, angles: Optional[List[float]] = None, normalize_intensity: bool = True) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Simulate FCPM intensity images for a director field.</p> <p>Physics: I(\u03b1) = [nx\u00b7cos(\u03b1) + ny\u00b7sin(\u03b1)]\u2074</p> <p>This follows from two-photon absorption where the absorption probability is proportional to cos\u2074(\u03b2), with \u03b2 being the angle between the excitation polarization and the transition dipole moment (parallel to director).</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>angles</code> <code>Optional[List[float]]</code> <p>List of polarization angles in radians.     Default is [0, \u03c0/4, \u03c0/2, 3\u03c0/4] (4 standard angles).</p> <code>None</code> <code>normalize_intensity</code> <code>bool</code> <p>If True, normalize max intensity to 1.0.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle -&gt; intensity array of shape (ny, nx, nz).</p>"},{"location":"api/core/#fcpm.core.simulate_fcpm_extended","title":"<code>fcpm.core.simulate_fcpm_extended(director: DirectorField, angles: Optional[List[float]] = None, include_z_contribution: bool = False) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Extended FCPM simulation with optional z-component effects.</p> <p>Standard FCPM: I(\u03b1) = [nx\u00b7cos(\u03b1) + ny\u00b7sin(\u03b1)]\u2074</p> <p>With z-contribution (models partial transmission of z-polarized light): I(\u03b1) \u221d (nx\u00b2 + ny\u00b2)\u00b2 * cos\u2074(effective_angle)</p> <p>In practice, the standard model is usually sufficient.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>angles</code> <code>Optional[List[float]]</code> <p>List of polarization angles in radians.</p> <code>None</code> <code>include_z_contribution</code> <code>bool</code> <p>Whether to modulate by (1 - nz\u00b2).</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle -&gt; intensity array.</p>"},{"location":"api/core/#q-tensor-functions","title":"Q-tensor Functions","text":""},{"location":"api/core/#fcpm.core.director_to_qtensor","title":"<code>fcpm.core.director_to_qtensor(director: DirectorField, S: float = 1.0) -&gt; QTensor</code>","text":"<p>Convert a director field to Q-tensor representation.</p> <p>Q_ij = S * (n_i * n_j - \u03b4_ij / 3)</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>S</code> <code>float</code> <p>Scalar order parameter (default 1.0 for perfect order).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>QTensor</code> <p>QTensor representation of the director field.</p>"},{"location":"api/core/#fcpm.core.qtensor_difference","title":"<code>fcpm.core.qtensor_difference(Q1: QTensor, Q2: QTensor) -&gt; np.ndarray</code>","text":"<p>Compute the Frobenius norm of the difference between two Q-tensors.</p> <p>This is a sign-invariant error metric: ||Q1 - Q2||_F</p> <p>Parameters:</p> Name Type Description Default <code>Q1, Q2</code> <p>Q-tensor fields to compare.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Per-voxel Frobenius norm of difference.</p>"},{"location":"api/io/","title":"I/O API","text":""},{"location":"api/io/#auto-detection-loaders","title":"Auto-detection Loaders","text":""},{"location":"api/io/#fcpm.io.load_director","title":"<code>fcpm.io.load_director(source: Union[str, Path, np.ndarray, Dict[str, np.ndarray]], **kwargs) -&gt; DirectorField</code>","text":"<p>Load director field with automatic format detection.</p> <p>This is the recommended entry point for loading director fields. Automatically detects the input type and calls the appropriate loader.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path, ndarray, Dict[str, ndarray]]</code> <p>Can be: - Path to .npz file (with nx, ny, nz keys) - Path to .npy file (4D array with shape (..., 3)) - Path to .mat file (MATLAB) - NumPy array (4D with shape (..., 3) or dict-like) - Dictionary with 'nx', 'ny', 'nz' keys</p> required <code>**kwargs</code> <p>Additional arguments passed to specific loaders.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField loaded from source.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # From file (auto-detect format)\n&gt;&gt;&gt; director = fcpm.load_director('director.npz')\n&gt;&gt;&gt; director = fcpm.load_director('data/director.mat')\n</code></pre> <pre><code>&gt;&gt;&gt; # From numpy array\n&gt;&gt;&gt; director = fcpm.load_director(my_array)\n</code></pre> <pre><code>&gt;&gt;&gt; # From dictionary\n&gt;&gt;&gt; director = fcpm.load_director({'nx': nx, 'ny': ny, 'nz': nz})\n</code></pre>"},{"location":"api/io/#fcpm.io.load_fcpm","title":"<code>fcpm.io.load_fcpm(source: Union[str, Path, Dict[float, np.ndarray], np.ndarray], angles: Optional[List[float]] = None, **kwargs) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Load FCPM intensity data with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path, Dict[float, ndarray], ndarray]</code> <p>Can be: - Path to .npz file - Path to .tif/.tiff file - Path to directory containing image files - Dictionary mapping angle -&gt; intensity (returns as-is) - 4D numpy array (angles, y, x, z)</p> required <code>angles</code> <code>Optional[List[float]]</code> <p>Polarization angles in radians (required for some formats).     Default: [0, \u03c0/4, \u03c0/2, 3\u03c0/4]</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to specific loaders.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle (float) to intensity array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; I_fcpm = fcpm.load_fcpm('intensities.npz')\n&gt;&gt;&gt; I_fcpm = fcpm.load_fcpm('data/fcpm_stack.tif', angles=[0, np.pi/4, np.pi/2])\n&gt;&gt;&gt; I_fcpm = fcpm.load_fcpm('data/images/', angles=[0, np.pi/4])\n</code></pre>"},{"location":"api/io/#director-loaders","title":"Director Loaders","text":""},{"location":"api/io/#fcpm.io.load_director_npz","title":"<code>fcpm.io.load_director_npz(filepath: Union[str, Path]) -&gt; DirectorField</code>","text":"<p>Load director field from NumPy .npz file.</p> <p>Supports multiple formats: 1. Keys 'nx', 'ny', 'nz' (standard format) 2. Key 'PATH' with shape (..., 3) (experimental format) 3. Key 'director' or 'n' with shape (..., 3)</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .npz file.</p> required <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField loaded from file.</p>"},{"location":"api/io/#fcpm.io.load_director_npy","title":"<code>fcpm.io.load_director_npy(filepath: Union[str, Path], component_order: str = 'xyz') -&gt; DirectorField</code>","text":"<p>Load director field from single .npy file.</p> <p>The file should contain a 4D array with shape (..., 3).</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .npy file.</p> required <code>component_order</code> <code>str</code> <p>Order of components in last axis ('xyz' or 'zyx').</p> <code>'xyz'</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField loaded from file.</p>"},{"location":"api/io/#fcpm.io.load_director_mat","title":"<code>fcpm.io.load_director_mat(filepath: Union[str, Path], nx_key: str = 'nx', ny_key: str = 'ny', nz_key: str = 'nz') -&gt; DirectorField</code>","text":"<p>Load director field from MATLAB .mat file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .mat file.</p> required <code>nx_key, ny_key, nz_key</code> <p>Variable names in the .mat file.</p> required <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField loaded from file.</p>"},{"location":"api/io/#fcpm.io.load_director_hdf5","title":"<code>fcpm.io.load_director_hdf5(filepath: Union[str, Path]) -&gt; DirectorField</code>","text":"<p>Load director field from HDF5 file.</p> <p>Expects datasets <code>nx</code>, <code>ny</code>, <code>nz</code> (as written by :func:<code>save_director_hdf5</code>).</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .h5 or .hdf5 file.</p> required <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField loaded from file.</p> Note <p>Requires h5py package.</p>"},{"location":"api/io/#fcpm.io.load_lcsim_npz","title":"<code>fcpm.io.load_lcsim_npz(filepath: Union[str, Path]) -&gt; Tuple[DirectorField, Dict[str, Any]]</code>","text":"<p>Load director field from LCSim/article.lcpen NPZ format.</p> <p>These files contain a <code>PATH</code> key with shape <code>(1, sx, sy, sz, 1, 3)</code> and an optional <code>settings</code> JSON string with Frank constants, pitch, and film thickness.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to NPZ file.</p> required <p>Returns:</p> Type Description <code>DirectorField</code> <p>Tuple of <code>(DirectorField, settings_dict)</code>.</p> <code>Dict[str, Any]</code> <p><code>settings_dict</code> may be empty if no settings were found.</p>"},{"location":"api/io/#fcpm-loaders","title":"FCPM Loaders","text":""},{"location":"api/io/#fcpm.io.load_fcpm_npz","title":"<code>fcpm.io.load_fcpm_npz(filepath: Union[str, Path]) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Load FCPM intensity data from .npz file.</p> <p>Expected format: keys are angle values (as strings), values are intensity arrays.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .npz file.</p> required <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle (radians) to intensity array.</p>"},{"location":"api/io/#fcpm.io.load_fcpm_tiff_stack","title":"<code>fcpm.io.load_fcpm_tiff_stack(filepath: Union[str, Path], angles: list, axis: int = 0) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Load FCPM data from TIFF stack.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to TIFF file.</p> required <code>angles</code> <code>list</code> <p>List of polarization angles in radians.</p> required <code>axis</code> <code>int</code> <p>Axis along which angles are stacked.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle to intensity.</p> Note <p>Requires tifffile package.</p>"},{"location":"api/io/#fcpm.io.load_fcpm_mat","title":"<code>fcpm.io.load_fcpm_mat(filepath: Union[str, Path], angles: Optional[List[float]] = None, intensity_key: Optional[str] = None) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Load FCPM intensities from MATLAB .mat file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .mat file.</p> required <code>angles</code> <code>Optional[List[float]]</code> <p>Polarization angles in radians.</p> <code>None</code> <code>intensity_key</code> <code>Optional[str]</code> <p>Variable name for intensity data. If None, auto-detect.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle to intensity.</p>"},{"location":"api/io/#other-loaders","title":"Other Loaders","text":""},{"location":"api/io/#fcpm.io.load_qtensor_npz","title":"<code>fcpm.io.load_qtensor_npz(filepath: Union[str, Path]) -&gt; QTensor</code>","text":"<p>Load Q-tensor field from .npz file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to .npz file.</p> required <p>Returns:</p> Type Description <code>QTensor</code> <p>QTensor loaded from file.</p>"},{"location":"api/io/#fcpm.io.load_simulation_results","title":"<code>fcpm.io.load_simulation_results(dirpath: Union[str, Path]) -&gt; Dict[str, Any]</code>","text":"<p>Load complete simulation results from a directory.</p> Expected structure <p>dirpath/     director.npz     fcpm_intensities.npz     qtensor.npz (optional)     metadata.json (optional)</p> <p>Parameters:</p> Name Type Description Default <code>dirpath</code> <code>Union[str, Path]</code> <p>Path to results directory.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with loaded data.</p>"},{"location":"api/io/#exporters","title":"Exporters","text":""},{"location":"api/io/#fcpm.io.save_director_npz","title":"<code>fcpm.io.save_director_npz(director: DirectorField, filepath: Union[str, Path], compressed: bool = True) -&gt; Path</code>","text":"<p>Save director field to NumPy .npz file.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to save.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path.</p> required <code>compressed</code> <code>bool</code> <p>Use compression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p>"},{"location":"api/io/#fcpm.io.save_director_npy","title":"<code>fcpm.io.save_director_npy(director: DirectorField, filepath: Union[str, Path]) -&gt; Path</code>","text":"<p>Save director field to single .npy file.</p> <p>Output shape: (ny, nx, nz, 3) with order [nx, ny, nz] in last axis.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to save.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p>"},{"location":"api/io/#fcpm.io.save_director_hdf5","title":"<code>fcpm.io.save_director_hdf5(director: DirectorField, filepath: Union[str, Path], metadata: Optional[Dict[str, Any]] = None) -&gt; Path</code>","text":"<p>Save director field to HDF5 format with gzip compression.</p> <p>Stores nx, ny, nz as separate datasets with optional metadata as HDF5 attributes.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to save.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path (.h5 or .hdf5).</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional metadata dictionary stored as HDF5 attributes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p> Note <p>Requires h5py package: <code>pip install h5py</code></p>"},{"location":"api/io/#fcpm.io.save_fcpm_npz","title":"<code>fcpm.io.save_fcpm_npz(I_fcpm: Dict[float, np.ndarray], filepath: Union[str, Path], compressed: bool = True) -&gt; Path</code>","text":"<p>Save FCPM intensity data to .npz file.</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle to intensity.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path.</p> required <code>compressed</code> <code>bool</code> <p>Use compression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p>"},{"location":"api/io/#fcpm.io.save_fcpm_tiff","title":"<code>fcpm.io.save_fcpm_tiff(I_fcpm: Dict[float, np.ndarray], filepath: Union[str, Path], z_idx: Optional[int] = None) -&gt; Path</code>","text":"<p>Save FCPM intensity data to TIFF file(s).</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>Dictionary mapping angle to intensity.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path (base name).</p> required <code>z_idx</code> <code>Optional[int]</code> <p>Specific z-slice to save (None = all slices).</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file(s).</p> Note <p>Requires tifffile package.</p>"},{"location":"api/io/#fcpm.io.save_qtensor_npz","title":"<code>fcpm.io.save_qtensor_npz(Q: QTensor, filepath: Union[str, Path], compressed: bool = True) -&gt; Path</code>","text":"<p>Save Q-tensor field to .npz file.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>QTensor</code> <p>Q-tensor to save.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path.</p> required <code>compressed</code> <code>bool</code> <p>Use compression.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p>"},{"location":"api/io/#fcpm.io.save_simulation_results","title":"<code>fcpm.io.save_simulation_results(results: Dict[str, Any], dirpath: Union[str, Path], overwrite: bool = False) -&gt; Path</code>","text":"<p>Save complete simulation results to a directory.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Dict[str, Any]</code> <p>Dictionary with 'director', 'fcpm', 'qtensor', 'metadata'.</p> required <code>dirpath</code> <code>Union[str, Path]</code> <p>Output directory.</p> required <code>overwrite</code> <code>bool</code> <p>Overwrite existing files.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to output directory.</p>"},{"location":"api/io/#fcpm.io.export_for_matlab","title":"<code>fcpm.io.export_for_matlab(director: DirectorField, filepath: Union[str, Path]) -&gt; Path</code>","text":"<p>Export director field for MATLAB.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to export.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p> Note <p>Requires scipy package.</p>"},{"location":"api/io/#fcpm.io.export_for_vtk","title":"<code>fcpm.io.export_for_vtk(director: DirectorField, filepath: Union[str, Path]) -&gt; Path</code>","text":"<p>Export director field as VTK file for ParaView/VisIt.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to export.</p> required <code>filepath</code> <code>Union[str, Path]</code> <p>Output path.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p> Note <p>Creates a structured points dataset with vector field.</p>"},{"location":"api/optimizers/","title":"Optimizers API","text":""},{"location":"api/optimizers/#combinedoptimizer","title":"CombinedOptimizer","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.CombinedOptimizer","title":"<code>fcpm.reconstruction.optimizers.CombinedOptimizer</code>","text":"<p>               Bases: <code>SignOptimizer</code></p> <p>Combined V1 optimizer: chain propagation + iterative local flip.</p> <p>This is the original recommended method from V1.  It is wrapped here for a uniform interface with V2 optimizers.</p> <p>Example::</p> <pre><code>optimizer = CombinedOptimizer()\nresult = optimizer.optimize(director, verbose=True)\n</code></pre>"},{"location":"api/optimizers/#layerpropagationoptimizer","title":"LayerPropagationOptimizer","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.LayerPropagationOptimizer","title":"<code>fcpm.reconstruction.optimizers.LayerPropagationOptimizer</code>","text":"<p>               Bases: <code>SignOptimizer</code></p> <p>Layer-by-layer propagation followed by iterative refinement.</p> <p>Phase 1 establishes z-continuity by aligning each layer with the previous one (fast, O(N)).  Phase 2 performs global iterative flipping to smooth remaining in-plane inconsistencies.</p> <p>Example::</p> <pre><code>optimizer = LayerPropagationOptimizer()\nresult = optimizer.optimize(director, verbose=True)\n</code></pre>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.LayerPropagationConfig","title":"<code>fcpm.reconstruction.optimizers.LayerPropagationConfig</code>  <code>dataclass</code>","text":"<p>Configuration for layer propagation optimizer.</p>"},{"location":"api/optimizers/#graphcutsoptimizer","title":"GraphCutsOptimizer","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.GraphCutsOptimizer","title":"<code>fcpm.reconstruction.optimizers.GraphCutsOptimizer</code>","text":"<p>               Bases: <code>SignOptimizer</code></p> <p>Graph cuts optimizer using min-cut/max-flow.</p> <p>Provides the globally optimal solution for the sign optimization problem when the energy function is submodular (smooth director fields).</p> <p>Example::</p> <pre><code>optimizer = GraphCutsOptimizer()\nresult = optimizer.optimize(director, verbose=True)\n</code></pre>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.GraphCutsConfig","title":"<code>fcpm.reconstruction.optimizers.GraphCutsConfig</code>  <code>dataclass</code>","text":"<p>Configuration for graph cuts optimization.</p>"},{"location":"api/optimizers/#simulatedannealingoptimizer","title":"SimulatedAnnealingOptimizer","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.SimulatedAnnealingOptimizer","title":"<code>fcpm.reconstruction.optimizers.SimulatedAnnealingOptimizer</code>","text":"<p>               Bases: <code>SignOptimizer</code></p> <p>Simulated annealing optimizer with adaptive temperature.</p> <p>Can escape local minima and find near-global optima, but is slower than deterministic methods like graph cuts.</p> <p>Example::</p> <pre><code>config = SimulatedAnnealingConfig(max_iterations=50000)\noptimizer = SimulatedAnnealingOptimizer(config)\nresult = optimizer.optimize(director, verbose=True)\n</code></pre>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.SimulatedAnnealingConfig","title":"<code>fcpm.reconstruction.optimizers.SimulatedAnnealingConfig</code>  <code>dataclass</code>","text":"<p>Configuration for simulated annealing.</p>"},{"location":"api/optimizers/#hierarchicaloptimizer","title":"HierarchicalOptimizer","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.HierarchicalOptimizer","title":"<code>fcpm.reconstruction.optimizers.HierarchicalOptimizer</code>","text":"<p>               Bases: <code>SignOptimizer</code></p> <p>Hierarchical coarse-to-fine optimizer.</p> <p>Good balance between speed and quality \u2014 captures global structure through coarsening and refines local details at full resolution.</p> <p>Example::</p> <pre><code>optimizer = HierarchicalOptimizer()\nresult = optimizer.optimize(director, verbose=True)\n</code></pre>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.HierarchicalConfig","title":"<code>fcpm.reconstruction.optimizers.HierarchicalConfig</code>  <code>dataclass</code>","text":"<p>Configuration for hierarchical optimization.</p>"},{"location":"api/optimizers/#beliefpropagationoptimizer","title":"BeliefPropagationOptimizer","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.BeliefPropagationOptimizer","title":"<code>fcpm.reconstruction.optimizers.BeliefPropagationOptimizer</code>","text":"<p>               Bases: <code>SignOptimizer</code></p> <p>Belief propagation optimizer using message passing.</p> <p>Treats sign optimization as probabilistic inference and uses loopy BP to approximate the MAP solution.</p> <p>.. note::     This optimizer is experimental. It may not converge for     highly irregular fields.</p> <p>Example::</p> <pre><code>config = BeliefPropagationConfig(max_iterations=50)\noptimizer = BeliefPropagationOptimizer(config)\nresult = optimizer.optimize(director, verbose=True)\n</code></pre>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.BeliefPropagationConfig","title":"<code>fcpm.reconstruction.optimizers.BeliefPropagationConfig</code>  <code>dataclass</code>","text":"<p>Configuration for belief propagation.</p>"},{"location":"api/optimizers/#functional-interfaces","title":"Functional Interfaces","text":""},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.graph_cuts_optimization","title":"<code>fcpm.reconstruction.optimizers.graph_cuts_optimization(director: DirectorField, verbose: bool = False, config: Optional[GraphCutsConfig] = None) -&gt; OptimizationResult</code>","text":"<p>Functional interface for graph cuts optimization.</p>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.simulated_annealing_optimization","title":"<code>fcpm.reconstruction.optimizers.simulated_annealing_optimization(director: DirectorField, verbose: bool = False, config: Optional[SimulatedAnnealingConfig] = None) -&gt; OptimizationResult</code>","text":"<p>Functional interface for simulated annealing optimization.</p>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.hierarchical_optimization","title":"<code>fcpm.reconstruction.optimizers.hierarchical_optimization(director: DirectorField, verbose: bool = False, config: Optional[HierarchicalConfig] = None) -&gt; OptimizationResult</code>","text":"<p>Functional interface for hierarchical optimization.</p>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.belief_propagation_optimization","title":"<code>fcpm.reconstruction.optimizers.belief_propagation_optimization(director: DirectorField, verbose: bool = False, config: Optional[BeliefPropagationConfig] = None) -&gt; OptimizationResult</code>","text":"<p>Functional interface for belief propagation optimization.</p>"},{"location":"api/optimizers/#fcpm.reconstruction.optimizers.layer_propagation_optimization","title":"<code>fcpm.reconstruction.optimizers.layer_propagation_optimization(director: DirectorField, verbose: bool = False, config: Optional[LayerPropagationConfig] = None) -&gt; OptimizationResult</code>","text":"<p>Functional interface for layer propagation optimization.</p>"},{"location":"api/reconstruction/","title":"Reconstruction API","text":""},{"location":"api/reconstruction/#q-tensor-reconstruction","title":"Q-tensor Reconstruction","text":""},{"location":"api/reconstruction/#fcpm.reconstruction.qtensor_from_fcpm","title":"<code>fcpm.reconstruction.qtensor_from_fcpm(I_fcpm: Dict[float, np.ndarray], S: float = 1.0) -&gt; Tuple[QTensor, Dict]</code>","text":"<p>Reconstruct Q-tensor components from FCPM intensities.</p> <p>This determines Q_xx, Q_yy, Q_xy EXACTLY from the measurements. Q_xz and Q_yz are set based on the unit constraint but have sign ambiguity that cannot be resolved from FCPM alone.</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>FCPM intensities at standard angles [0, \u03c0/4, \u03c0/2, 3\u03c0/4].</p> required <code>S</code> <code>float</code> <p>Assumed scalar order parameter.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Tuple[QTensor, Dict]</code> <p>Tuple of (QTensor, info_dict with reconstruction details).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.qtensor_from_fcpm_exact","title":"<code>fcpm.reconstruction.qtensor_from_fcpm_exact(I_fcpm: Dict[float, np.ndarray], S: float = 1.0) -&gt; Tuple[QTensor, Dict]</code>","text":"<p>Reconstruct ONLY the exactly determinable Q-tensor components.</p> <p>Sets Q_xz = Q_yz = 0 since these cannot be determined from FCPM. The director extraction will work but may have errors in nz.</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>FCPM intensities.</p> required <code>S</code> <code>float</code> <p>Scalar order parameter.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Tuple[QTensor, Dict]</code> <p>Tuple of (QTensor with Q_xz=Q_yz=0, info_dict).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.reconstruct_via_qtensor","title":"<code>fcpm.reconstruction.reconstruct_via_qtensor(I_fcpm: Dict[float, np.ndarray], S: float = 1.0, vectorized: bool = True) -&gt; Tuple[DirectorField, QTensor, Dict]</code>","text":"<p>Full reconstruction pipeline using Q-tensor approach.</p> <p>Steps: 1. Reconstruct Q-tensor components from FCPM 2. Extract director via eigendecomposition 3. Director has arbitrary sign (\u00b1n) at each point</p> <p>Note: Sign consistency must be enforced separately using the sign_optimization module.</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>FCPM intensities.</p> required <code>S</code> <code>float</code> <p>Scalar order parameter.</p> <code>1.0</code> <code>vectorized</code> <code>bool</code> <p>Use vectorized eigendecomposition (faster).</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[DirectorField, QTensor, Dict]</code> <p>Tuple of (DirectorField, QTensor, info_dict).</p>"},{"location":"api/reconstruction/#direct-reconstruction","title":"Direct Reconstruction","text":""},{"location":"api/reconstruction/#fcpm.reconstruction.reconstruct_director_direct","title":"<code>fcpm.reconstruction.reconstruct_director_direct(I_fcpm: Dict[float, np.ndarray], sign_nz_positive: bool = True) -&gt; DirectorField</code>","text":"<p>Reconstruct director field using direct inversion.</p> <p>This method uses: 1. Magnitude extraction from I(0), I(\u03c0/2) 2. Sign determination for nx\u00b7ny from I(\u03c0/4), I(3\u03c0/4) 3. Unit constraint for nz magnitude 4. Assumed positive nz (can be flipped later)</p> <p>Limitations: - Individual signs of nx, ny are ambiguous (but product nx\u00b7ny is known) - Sign of nz is assumed (typically positive for upward-facing samples)</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>Dictionary of FCPM intensities.</p> required <code>sign_nz_positive</code> <code>bool</code> <p>Assume nz &gt;= 0 everywhere.</p> <code>True</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>Reconstructed DirectorField.</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.reconstruct_director_all_angles","title":"<code>fcpm.reconstruction.reconstruct_director_all_angles(I_fcpm: Dict[float, np.ndarray]) -&gt; DirectorField</code>","text":"<p>Reconstruct director using all available angles via least-squares.</p> <p>This method fits the model I(\u03b1) = [nx\u00b7cos(\u03b1) + ny\u00b7sin(\u03b1)]\u2074 to all available angle measurements.</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>Dictionary of FCPM intensities (any number of angles).</p> required <p>Returns:</p> Type Description <code>DirectorField</code> <p>Reconstructed DirectorField.</p>"},{"location":"api/reconstruction/#sign-optimization-v1-functions","title":"Sign Optimization (V1 Functions)","text":""},{"location":"api/reconstruction/#fcpm.reconstruction.combined_optimization","title":"<code>fcpm.reconstruction.combined_optimization(director: DirectorField, verbose: bool = False) -&gt; Tuple[DirectorField, Dict]</code>","text":"<p>Combined approach: chain propagation + local refinement.</p> <p>This is the recommended method for most cases: 1. Chain propagation establishes global consistency 2. Local flipping removes remaining errors</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>verbose</code> <code>bool</code> <p>Print progress.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[DirectorField, Dict]</code> <p>Tuple of (optimized DirectorField, info dict).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.chain_propagation","title":"<code>fcpm.reconstruction.chain_propagation(director: DirectorField, start: Optional[Tuple[int, int, int]] = None) -&gt; DirectorField</code>","text":"<p>Fix director signs via BFS chain propagation from a seed point.</p> <p>Algorithm: 1. Start from seed point with fixed orientation 2. BFS through all voxels 3. For each new voxel, align with the already-fixed neighbor</p> <p>This ensures local consistency but may create domain walls if the field has topological defects.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field (signs may be inconsistent).</p> required <code>start</code> <code>Optional[Tuple[int, int, int]]</code> <p>Starting point (y, x, z). If None, uses center.</p> <code>None</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField with consistent signs.</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.iterative_local_flip","title":"<code>fcpm.reconstruction.iterative_local_flip(director: DirectorField, max_iter: int = 100, verbose: bool = False) -&gt; Tuple[DirectorField, Dict]</code>","text":"<p>Iteratively flip signs to minimize gradient energy.</p> <p>At each iteration, for each voxel, compare the cost of keeping the current sign vs. flipping. Flip if it reduces energy.</p> <p>Energy: E = \u03a3 |n_i - n_j|\u00b2 over neighbor pairs</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>max_iter</code> <code>int</code> <p>Maximum iterations.</p> <code>100</code> <code>verbose</code> <code>bool</code> <p>Print progress.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[DirectorField, Dict]</code> <p>Tuple of (optimized DirectorField, info dict).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.wavefront_propagation","title":"<code>fcpm.reconstruction.wavefront_propagation(director: DirectorField, direction: str = 'z+') -&gt; DirectorField</code>","text":"<p>Propagate sign fixing as a wavefront in a specific direction.</p> <p>This sweeps through the volume, aligning each plane with the previous. Useful when there's a known \"good\" starting plane.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>direction</code> <code>str</code> <p>Propagation direction ('x+', 'x-', 'y+', 'y-', 'z+', 'z-').</p> <code>'z+'</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField with fixed signs.</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.multi_axis_propagation","title":"<code>fcpm.reconstruction.multi_axis_propagation(director: DirectorField, axes_order: List[int] = [2, 0, 1]) -&gt; DirectorField</code>","text":"<p>Apply vectorized chain propagation along multiple axes.</p> <p>Propagates from the center slice outward along each axis.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field.</p> required <code>axes_order</code> <code>List[int]</code> <p>Order of axes to propagate (default: z, y, x).</p> <code>[2, 0, 1]</code> <p>Returns:</p> Type Description <code>DirectorField</code> <p>DirectorField with fixed signs.</p>"},{"location":"api/reconstruction/#energy-functions","title":"Energy Functions","text":""},{"location":"api/reconstruction/#fcpm.reconstruction.compute_gradient_energy","title":"<code>fcpm.reconstruction.compute_gradient_energy(directors: Union[np.ndarray, DirectorField]) -&gt; float</code>","text":"<p>Compute the total gradient energy (squared-difference approximation).</p> <p>E = sum_{axes} sum |n_i - n_{i+1}|^2</p> <p>This is the standard cost function minimised by all sign optimizers. Lower energy indicates a smoother, more physically realistic field.</p> <p>Parameters:</p> Name Type Description Default <code>directors</code> <code>Union[ndarray, DirectorField]</code> <p>Either a raw <code>(ny, nx, nz, 3)</code> array or a :class:<code>DirectorField</code>.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total gradient energy (scalar).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.energy.FrankConstants","title":"<code>fcpm.reconstruction.energy.FrankConstants</code>  <code>dataclass</code>","text":"<p>Frank elastic constants for a nematic/cholesteric liquid crystal.</p> <p>Default values are typical for 5CB-like nematics (in pN). For cholesterics, set pitch to a finite value; for nematics, leave <code>pitch=None</code> (equivalent to infinite pitch, i.e. q0 = 0).</p> References <p>de Gennes &amp; Prost, The Physics of Liquid Crystals, 1993.</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.energy.FrankConstants.q0","title":"<code>q0: float</code>  <code>property</code>","text":"<p>Equilibrium twist wave-vector 2*pi / pitch (rad / voxel).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.energy.compute_frank_energy_anisotropic","title":"<code>fcpm.reconstruction.energy.compute_frank_energy_anisotropic(directors: Union[np.ndarray, DirectorField], constants: Optional[FrankConstants] = None, voxel_size: float = 1.0) -&gt; Dict[str, np.ndarray | float]</code>","text":"<p>Compute the full anisotropic Frank elastic energy.</p> <p>Decomposes into splay, twist, and bend contributions using central finite differences for the spatial derivatives.</p> <p>Parameters:</p> Name Type Description Default <code>directors</code> <code>Union[ndarray, DirectorField]</code> <p>Director field as <code>(ny, nx, nz, 3)</code> array or :class:<code>DirectorField</code>.</p> required <code>constants</code> <code>Optional[FrankConstants]</code> <p>Frank elastic constants.  Uses defaults if <code>None</code>.</p> <code>None</code> <code>voxel_size</code> <code>float</code> <p>Physical size of a voxel (isotropic assumed).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Dict[str, ndarray | float]</code> <p>Dictionary with keys:</p> <code>Dict[str, ndarray | float]</code> <ul> <li><code>splay</code> \u2014 per-voxel splay energy density array</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>twist</code> \u2014 per-voxel twist energy density array</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>bend</code>  \u2014 per-voxel bend energy density array</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>total</code> \u2014 per-voxel total energy density array</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>total_integrated</code> \u2014 scalar integral over volume</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>splay_integrated</code>, <code>twist_integrated</code>, <code>bend_integrated</code></li> </ul>"},{"location":"api/reconstruction/#base-classes","title":"Base Classes","text":""},{"location":"api/reconstruction/#fcpm.reconstruction.base.SignOptimizer","title":"<code>fcpm.reconstruction.base.SignOptimizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all sign-optimization strategies.</p> <p>Every optimizer must implement :meth:<code>optimize</code> which accepts a <code>DirectorField</code> with arbitrary signs and returns an <code>OptimizationResult</code> containing the sign-consistent field.</p> <p>Example::</p> <pre><code>class MyOptimizer(SignOptimizer):\n    def optimize(self, director, verbose=False):\n        ...\n        return OptimizationResult(director=..., ...)\n</code></pre>"},{"location":"api/reconstruction/#fcpm.reconstruction.base.SignOptimizer.optimize","title":"<code>optimize(director: DirectorField, verbose: bool = False) -&gt; OptimizationResult</code>  <code>abstractmethod</code>","text":"<p>Run the sign-optimization algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Input director field with potentially inconsistent signs.</p> required <code>verbose</code> <code>bool</code> <p>If <code>True</code>, print progress to stdout.</p> <code>False</code> <p>Returns:</p> Type Description <code>OptimizationResult</code> <p>An <code>OptimizationResult</code> with the optimized field and statistics.</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.base.OptimizationResult","title":"<code>fcpm.reconstruction.base.OptimizationResult</code>  <code>dataclass</code>","text":"<p>Result container returned by every SignOptimizer.</p> <p>Attributes:</p> Name Type Description <code>director</code> <code>DirectorField</code> <p>Optimized director field with consistent signs.</p> <code>initial_energy</code> <code>float</code> <p>Gradient energy before optimization.</p> <code>final_energy</code> <code>float</code> <p>Gradient energy after optimization.</p> <code>energy_by_layer</code> <code>List[float]</code> <p>Per-layer energy snapshots (if applicable).</p> <code>flips_by_layer</code> <code>List[int]</code> <p>Number of sign flips per layer (if applicable).</p> <code>total_flips</code> <code>int</code> <p>Total number of voxels whose sign was changed.</p> <code>method</code> <code>str</code> <p>Short identifier for the optimizer that produced this result.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Extensible dict for optimizer-specific information (e.g. <code>converged</code>, <code>iterations</code>, <code>history</code>).</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.base.OptimizationResult.energy_reduction","title":"<code>energy_reduction: float</code>  <code>property</code>","text":"<p>Absolute energy reduction.</p>"},{"location":"api/reconstruction/#fcpm.reconstruction.base.OptimizationResult.energy_reduction_pct","title":"<code>energy_reduction_pct: float</code>  <code>property</code>","text":"<p>Percentage energy reduction (0-100).</p>"},{"location":"api/utils/","title":"Utilities API","text":""},{"location":"api/utils/#metrics","title":"Metrics","text":""},{"location":"api/utils/#fcpm.utils.angular_error_nematic","title":"<code>fcpm.utils.angular_error_nematic(director_recon: DirectorField, director_gt: DirectorField) -&gt; np.ndarray</code>","text":"<p>Compute nematic-aware angular error.</p> <p>Since n \u2261 -n in nematics, we use:     \u03b8 = arccos(|n1 \u00b7 n2|)</p> <p>This gives the minimum angle between the orientations, accounting for the head-tail equivalence.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director field.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director field.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Angular error in degrees for each voxel.</p>"},{"location":"api/utils/#fcpm.utils.angular_error_vector","title":"<code>fcpm.utils.angular_error_vector(director_recon: DirectorField, director_gt: DirectorField) -&gt; np.ndarray</code>","text":"<p>Compute standard (vector) angular error.</p> <p>This does NOT account for nematic symmetry. Use angular_error_nematic() for proper nematic comparison.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director field.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director field.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Angular error in degrees.</p>"},{"location":"api/utils/#fcpm.utils.euclidean_error","title":"<code>fcpm.utils.euclidean_error(director_recon: DirectorField, director_gt: DirectorField) -&gt; np.ndarray</code>","text":"<p>Compute Euclidean distance between directors.</p> <p>Note: This is NOT nematic-aware.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director field.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director field.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Euclidean distance |n1 - n2| for each voxel.</p>"},{"location":"api/utils/#fcpm.utils.euclidean_error_nematic","title":"<code>fcpm.utils.euclidean_error_nematic(director_recon: DirectorField, director_gt: DirectorField) -&gt; np.ndarray</code>","text":"<p>Compute nematic-aware Euclidean error.</p> <p>For each voxel, compute min(|n1 - n2|, |n1 + n2|).</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director field.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director field.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Minimum Euclidean distance.</p>"},{"location":"api/utils/#fcpm.utils.intensity_reconstruction_error","title":"<code>fcpm.utils.intensity_reconstruction_error(I_original: Dict[float, np.ndarray], I_reconstructed: Dict[float, np.ndarray]) -&gt; Dict[str, float]</code>","text":"<p>Compute FCPM intensity reconstruction error.</p> <p>This is the DEFINITIVE test for reconstruction quality: If the reconstructed director produces the same FCPM signal as the ground truth, the reconstruction is physically correct (up to allowed symmetries).</p> <p>Parameters:</p> Name Type Description Default <code>I_original</code> <code>Dict[float, ndarray]</code> <p>Original FCPM intensities.</p> required <code>I_reconstructed</code> <code>Dict[float, ndarray]</code> <p>Reconstructed intensities from recovered director.</p> required <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary of error metrics.</p>"},{"location":"api/utils/#fcpm.utils.qtensor_frobenius_error","title":"<code>fcpm.utils.qtensor_frobenius_error(Q_recon: QTensor, Q_gt: QTensor) -&gt; np.ndarray</code>","text":"<p>Compute Frobenius norm of Q-tensor difference.</p> <p>||Q1 - Q2||_F = sqrt(Tr((Q1-Q2)\u00b2))</p> <p>This is sign-invariant since Q(n) = Q(-n).</p> <p>Parameters:</p> Name Type Description Default <code>Q_recon</code> <code>QTensor</code> <p>Reconstructed Q-tensor.</p> required <code>Q_gt</code> <code>QTensor</code> <p>Ground truth Q-tensor.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Frobenius error for each voxel.</p>"},{"location":"api/utils/#fcpm.utils.sign_accuracy","title":"<code>fcpm.utils.sign_accuracy(director_recon: DirectorField, director_gt: DirectorField) -&gt; float</code>","text":"<p>Compute the fraction of voxels where the sign is correct.</p> <p>A voxel has the correct sign when <code>dot(n_recon, n_gt) &gt; 0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director field.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director field.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Fraction in [0, 1].  1.0 means every voxel has matching sign.</p>"},{"location":"api/utils/#fcpm.utils.spatial_error_distribution","title":"<code>fcpm.utils.spatial_error_distribution(director_recon: DirectorField, director_gt: DirectorField) -&gt; Dict[str, np.ndarray | float]</code>","text":"<p>Compute per-z-layer angular error statistics and full error map.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director field.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director field.</p> required <p>Returns:</p> Type Description <code>Dict[str, ndarray | float]</code> <p>Dictionary with keys:</p> <code>Dict[str, ndarray | float]</code> <ul> <li><code>error_map</code> \u2014 full <code>(ny, nx, nz)</code> angular error array (degrees)</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>layer_mean</code> \u2014 <code>(nz,)</code> mean angular error per z-layer</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>layer_median</code> \u2014 <code>(nz,)</code> median angular error per z-layer</li> </ul> <code>Dict[str, ndarray | float]</code> <ul> <li><code>layer_max</code> \u2014 <code>(nz,)</code> max angular error per z-layer</li> </ul>"},{"location":"api/utils/#fcpm.utils.summary_metrics","title":"<code>fcpm.utils.summary_metrics(director_recon: DirectorField, director_gt: DirectorField, I_original: Optional[Dict[float, np.ndarray]] = None, I_reconstructed: Optional[Dict[float, np.ndarray]] = None) -&gt; Dict[str, float]</code>","text":"<p>Compute comprehensive summary metrics.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director.</p> required <code>I_original</code> <code>Optional[Dict[float, ndarray]]</code> <p>Original FCPM intensities.</p> <code>None</code> <code>I_reconstructed</code> <code>Optional[Dict[float, ndarray]]</code> <p>Reconstructed intensities.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary of all metrics.</p>"},{"location":"api/utils/#fcpm.utils.perfect_reconstruction_test","title":"<code>fcpm.utils.perfect_reconstruction_test(director_recon: DirectorField, director_gt: DirectorField, tolerance: float = 0.1) -&gt; Tuple[bool, Dict]</code>","text":"<p>Test if reconstruction is perfect (within tolerance).</p> <p>A perfect reconstruction has either: - Very small angular error, OR - Perfect FCPM intensity reconstruction</p> <p>Due to nematic symmetry, angular error can be large (up to 180\u00b0) even for perfect reconstructions if signs are flipped.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director.</p> required <code>tolerance</code> <code>float</code> <p>Angular tolerance in degrees.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>Tuple[bool, Dict]</code> <p>Tuple of (is_perfect: bool, details: dict).</p>"},{"location":"api/utils/#noise","title":"Noise","text":""},{"location":"api/utils/#fcpm.utils.add_gaussian_noise","title":"<code>fcpm.utils.add_gaussian_noise(data: np.ndarray, sigma: float = 0.05, relative: bool = True, seed: Optional[int] = None) -&gt; np.ndarray</code>","text":"<p>Add Gaussian noise to data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input array.</p> required <code>sigma</code> <code>float</code> <p>Noise standard deviation.</p> <code>0.05</code> <code>relative</code> <code>bool</code> <p>If True, sigma is relative to data max.</p> <code>True</code> <code>seed</code> <code>Optional[int]</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Noisy data.</p>"},{"location":"api/utils/#fcpm.utils.add_poisson_noise","title":"<code>fcpm.utils.add_poisson_noise(data: np.ndarray, photon_count: float = 1000.0, seed: Optional[int] = None) -&gt; np.ndarray</code>","text":"<p>Add Poisson (shot) noise to simulate photon counting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input array (interpreted as expected photon rate).</p> required <code>photon_count</code> <code>float</code> <p>Scale factor for photon counts.</p> <code>1000.0</code> <code>seed</code> <code>Optional[int]</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Noisy data with Poisson statistics.</p>"},{"location":"api/utils/#fcpm.utils.add_salt_pepper_noise","title":"<code>fcpm.utils.add_salt_pepper_noise(data: np.ndarray, fraction: float = 0.01, seed: Optional[int] = None) -&gt; np.ndarray</code>","text":"<p>Add salt and pepper noise (random extreme values).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input array.</p> required <code>fraction</code> <code>float</code> <p>Fraction of pixels to affect.</p> <code>0.01</code> <code>seed</code> <code>Optional[int]</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Noisy data.</p>"},{"location":"api/utils/#fcpm.utils.add_fcpm_realistic_noise","title":"<code>fcpm.utils.add_fcpm_realistic_noise(I_fcpm: Dict[float, np.ndarray], noise_model: str = 'mixed', gaussian_sigma: float = 0.02, photon_count: float = 10000.0, seed: Optional[int] = None) -&gt; Dict[float, np.ndarray]</code>","text":"<p>Add realistic noise to FCPM intensity data.</p> <p>Realistic noise includes: - Shot noise (Poisson) from photon counting - Read noise (Gaussian) from detector - Background noise</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>Dictionary of FCPM intensities.</p> required <code>noise_model</code> <code>str</code> <p>'gaussian', 'poisson', or 'mixed'.</p> <code>'mixed'</code> <code>gaussian_sigma</code> <code>float</code> <p>Gaussian noise level.</p> <code>0.02</code> <code>photon_count</code> <code>float</code> <p>Expected photon count for Poisson.</p> <code>10000.0</code> <code>seed</code> <code>Optional[int]</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[float, ndarray]</code> <p>Noisy FCPM intensities.</p>"},{"location":"api/utils/#fcpm.utils.estimate_noise_level","title":"<code>fcpm.utils.estimate_noise_level(data: np.ndarray, method: str = 'mad') -&gt; float</code>","text":"<p>Estimate noise level in data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input data.</p> required <code>method</code> <code>str</code> <p>'std' (standard deviation), 'mad' (median absolute deviation).</p> <code>'mad'</code> <p>Returns:</p> Type Description <code>float</code> <p>Estimated noise level.</p>"},{"location":"api/utils/#fcpm.utils.signal_to_noise_ratio","title":"<code>fcpm.utils.signal_to_noise_ratio(signal: np.ndarray, noise: np.ndarray) -&gt; float</code>","text":"<p>Compute signal-to-noise ratio (SNR).</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>Signal array.</p> required <code>noise</code> <code>ndarray</code> <p>Noise array (or noisy data minus signal).</p> required <p>Returns:</p> Type Description <code>float</code> <p>SNR in dB.</p>"},{"location":"api/visualization/","title":"Visualization API","text":""},{"location":"api/visualization/#director-plots","title":"Director Plots","text":""},{"location":"api/visualization/#fcpm.visualization.plot_director_slice","title":"<code>fcpm.visualization.plot_director_slice(director: DirectorField, z_idx: int, step: int = 1, scale: float = 0.8, color_by: str = 'angle', cmap: str = 'hsv', ax: Optional[plt.Axes] = None, figsize: Tuple[float, float] = (10, 8), title: Optional[str] = None, show_colorbar: bool = True) -&gt; plt.Figure</code>","text":"<p>Plot a 2D slice of the director field as arrows.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to visualize.</p> required <code>z_idx</code> <code>int</code> <p>Index of z-slice to plot.</p> required <code>step</code> <code>int</code> <p>Subsampling step (1 = all points, 2 = every other, etc.).</p> <code>1</code> <code>scale</code> <code>float</code> <p>Arrow length scale factor.</p> <code>0.8</code> <code>color_by</code> <code>str</code> <p>Color arrows by 'angle' (in-plane), 'nz' (out-of-plane),       'magnitude', or None (uniform color).</p> <code>'angle'</code> <code>cmap</code> <code>str</code> <p>Colormap name.</p> <code>'hsv'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Matplotlib axes (created if None).</p> <code>None</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size if creating new figure.</p> <code>(10, 8)</code> <code>title</code> <code>Optional[str]</code> <p>Plot title.</p> <code>None</code> <code>show_colorbar</code> <code>bool</code> <p>Whether to show colorbar.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_director_streamlines","title":"<code>fcpm.visualization.plot_director_streamlines(director: DirectorField, z_idx: int, density: float = 1.0, color_by: str = 'angle', cmap: str = 'twilight', ax: Optional[plt.Axes] = None, figsize: Tuple[float, float] = (10, 8), title: Optional[str] = None) -&gt; plt.Figure</code>","text":"<p>Plot director field as streamlines (integral curves).</p> <p>Note: Due to nematic symmetry, streamlines may have discontinuities.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to visualize.</p> required <code>z_idx</code> <code>int</code> <p>Index of z-slice.</p> required <code>density</code> <code>float</code> <p>Streamline density.</p> <code>1.0</code> <code>color_by</code> <code>str</code> <p>Color by 'angle', 'nz', or 'speed'.</p> <code>'angle'</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'twilight'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Matplotlib axes.</p> <code>None</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(10, 8)</code> <code>title</code> <code>Optional[str]</code> <p>Plot title.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_director_rgb","title":"<code>fcpm.visualization.plot_director_rgb(director: DirectorField, z_idx: int, ax: Optional[plt.Axes] = None, figsize: Tuple[float, float] = (10, 8), title: Optional[str] = None) -&gt; plt.Figure</code>","text":"<p>Plot director orientation as RGB color image.</p> <p>Color mapping: - Hue: in-plane angle (0 to \u03c0 mapped to 0 to 1) - Saturation: in-plane magnitude - Value: 1 - |nz| (bright = in-plane, dark = out-of-plane)</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field.</p> required <code>z_idx</code> <code>int</code> <p>Z-slice index.</p> required <code>ax</code> <code>Optional[Axes]</code> <p>Matplotlib axes.</p> <code>None</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(10, 8)</code> <code>title</code> <code>Optional[str]</code> <p>Plot title.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_fcpm_intensities","title":"<code>fcpm.visualization.plot_fcpm_intensities(I_fcpm: Dict[float, np.ndarray], z_idx: int, figsize: Tuple[float, float] = (12, 3), cmap: str = 'gray') -&gt; plt.Figure</code>","text":"<p>Plot FCPM intensity images for all angles.</p> <p>Parameters:</p> Name Type Description Default <code>I_fcpm</code> <code>Dict[float, ndarray]</code> <p>Dictionary of FCPM intensities.</p> required <code>z_idx</code> <code>int</code> <p>Z-slice index.</p> required <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(12, 3)</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'gray'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#comparison","title":"Comparison","text":""},{"location":"api/visualization/#fcpm.visualization.compare_directors","title":"<code>fcpm.visualization.compare_directors(director1: DirectorField, director2: DirectorField, z_idx: int, step: int = 2, labels: Tuple[str, str] = ('Ground Truth', 'Reconstructed'), figsize: Tuple[float, float] = (14, 5)) -&gt; plt.Figure</code>","text":"<p>Side-by-side comparison of two director fields.</p> <p>Parameters:</p> Name Type Description Default <code>director1, director2</code> <p>Director fields to compare.</p> required <code>z_idx</code> <code>int</code> <p>Z-slice index.</p> required <code>step</code> <code>int</code> <p>Subsampling step.</p> <code>2</code> <code>labels</code> <code>Tuple[str, str]</code> <p>Labels for the two fields.</p> <code>('Ground Truth', 'Reconstructed')</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(14, 5)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_error_map","title":"<code>fcpm.visualization.plot_error_map(director_recon: DirectorField, director_gt: DirectorField, z_idx: int, error_type: str = 'angular', ax: Optional[plt.Axes] = None, figsize: Tuple[float, float] = (8, 6), cmap: str = 'hot') -&gt; plt.Figure</code>","text":"<p>Plot spatial map of reconstruction error.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director.</p> required <code>z_idx</code> <code>int</code> <p>Z-slice index.</p> required <code>error_type</code> <code>str</code> <p>'angular' (nematic-aware angle) or 'euclidean'.</p> <code>'angular'</code> <code>ax</code> <code>Optional[Axes]</code> <p>Matplotlib axes.</p> <code>None</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(8, 6)</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'hot'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#analysis-plots","title":"Analysis Plots","text":""},{"location":"api/visualization/#fcpm.visualization.plot_error_histogram","title":"<code>fcpm.visualization.plot_error_histogram(director_recon: DirectorField, director_gt: DirectorField, bins: int = 50, figsize: Tuple[float, float] = (10, 4)) -&gt; plt.Figure</code>","text":"<p>Plot histogram of angular errors.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director.</p> required <code>bins</code> <code>int</code> <p>Number of histogram bins.</p> <code>50</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(10, 4)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_error_by_depth","title":"<code>fcpm.visualization.plot_error_by_depth(director_recon: DirectorField, director_gt: DirectorField, figsize: Tuple[float, float] = (8, 5)) -&gt; plt.Figure</code>","text":"<p>Plot error statistics as a function of depth (z).</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director.</p> required <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(8, 5)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_intensity_reconstruction","title":"<code>fcpm.visualization.plot_intensity_reconstruction(I_original: Dict[float, np.ndarray], I_reconstructed: Dict[float, np.ndarray], z_idx: int, figsize: Tuple[float, float] = (14, 5)) -&gt; plt.Figure</code>","text":"<p>Compare original and reconstructed FCPM intensities.</p> <p>Parameters:</p> Name Type Description Default <code>I_original</code> <code>Dict[float, ndarray]</code> <p>Original FCPM intensities.</p> required <code>I_reconstructed</code> <code>Dict[float, ndarray]</code> <p>Reconstructed FCPM intensities.</p> required <code>z_idx</code> <code>int</code> <p>Z-slice to display.</p> required <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(14, 5)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_convergence","title":"<code>fcpm.visualization.plot_convergence(history: List[Dict], figsize: Tuple[float, float] = (10, 4)) -&gt; plt.Figure</code>","text":"<p>Plot convergence history from iterative optimization.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>List[Dict]</code> <p>List of dicts with 'iteration', 'energy', 'flipped' keys.</p> required <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(10, 4)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#q-tensor-plots","title":"Q-tensor Plots","text":""},{"location":"api/visualization/#fcpm.visualization.plot_qtensor_components","title":"<code>fcpm.visualization.plot_qtensor_components(Q: QTensor, z_idx: int, figsize: Tuple[float, float] = (15, 8)) -&gt; plt.Figure</code>","text":"<p>Plot all Q-tensor components at a specific z-slice.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>QTensor</code> <p>Q-tensor field.</p> required <code>z_idx</code> <code>int</code> <p>Z-slice index.</p> required <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(15, 8)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.plot_order_parameter","title":"<code>fcpm.visualization.plot_order_parameter(Q: QTensor, z_idx: Optional[int] = None, figsize: Tuple[float, float] = (8, 6)) -&gt; plt.Figure</code>","text":"<p>Plot the scalar order parameter S distribution.</p> <p>Parameters:</p> Name Type Description Default <code>Q</code> <code>QTensor</code> <p>Q-tensor field.</p> required <code>z_idx</code> <code>Optional[int]</code> <p>Z-slice index (None for all slices).</p> <code>None</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(8, 6)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#3d-visualization","title":"3D Visualization","text":""},{"location":"api/visualization/#fcpm.visualization.visualize_3d_matplotlib","title":"<code>fcpm.visualization.visualize_3d_matplotlib(director: DirectorField, subsample: int = 2, color_by: str = 'nz', figsize: Tuple[float, float] = (10, 8), elevation: float = 20, azimuth: float = 45) -&gt; Any</code>","text":"<p>3D visualization using matplotlib (fallback when TopoVec unavailable).</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field.</p> required <code>subsample</code> <code>int</code> <p>Subsampling factor.</p> <code>2</code> <code>color_by</code> <code>str</code> <p>Color coding.</p> <code>'nz'</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>Figure size.</p> <code>(10, 8)</code> <code>elevation</code> <code>float</code> <p>Viewing elevation angle.</p> <code>20</code> <code>azimuth</code> <code>float</code> <p>Viewing azimuth angle.</p> <code>45</code> <p>Returns:</p> Type Description <code>Any</code> <p>Matplotlib figure.</p>"},{"location":"api/visualization/#fcpm.visualization.export_for_paraview","title":"<code>fcpm.visualization.export_for_paraview(director: DirectorField, filename: Union[str, Path], format: str = 'vtk') -&gt; Path</code>","text":"<p>Export director field for visualization in ParaView.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to export.</p> required <code>filename</code> <code>Union[str, Path]</code> <p>Output filename (without extension).</p> required <code>format</code> <code>str</code> <p>Output format ('vtk' or 'vtu').</p> <code>'vtk'</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to saved file.</p> Note <p>Requires the 'vtk' package for VTK format export.</p>"},{"location":"api/visualization/#fcpm.visualization.check_topovec_available","title":"<code>fcpm.visualization.check_topovec_available() -&gt; bool</code>","text":"<p>Check if TopoVec is installed and available.</p>"},{"location":"api/visualization/#fcpm.visualization.visualize_topovec","title":"<code>fcpm.visualization.visualize_topovec(director: DirectorField, color_by: str = 'nz', scale: float = 1.0, subsample: int = 1, title: Optional[str] = None, **kwargs) -&gt; Any</code>","text":"<p>Visualize director field using TopoVec.</p> <p>Parameters:</p> Name Type Description Default <code>director</code> <code>DirectorField</code> <p>Director field to visualize.</p> required <code>color_by</code> <code>str</code> <p>Color coding ('nz', 'angle', 'uniform').</p> <code>'nz'</code> <code>scale</code> <code>float</code> <p>Glyph scale factor.</p> <code>1.0</code> <code>subsample</code> <code>int</code> <p>Subsampling factor.</p> <code>1</code> <code>title</code> <code>Optional[str]</code> <p>Visualization title.</p> <code>None</code> <code>**kwargs</code> <p>Additional TopoVec parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>TopoVec visualization object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If TopoVec is not installed.</p>"},{"location":"api/visualization/#statistics","title":"Statistics","text":""},{"location":"api/visualization/#fcpm.visualization.summary_statistics","title":"<code>fcpm.visualization.summary_statistics(director_recon: DirectorField, director_gt: DirectorField, I_original: Optional[Dict[float, np.ndarray]] = None, I_reconstructed: Optional[Dict[float, np.ndarray]] = None) -&gt; Dict[str, float]</code>","text":"<p>Compute summary statistics for reconstruction quality.</p> <p>Parameters:</p> Name Type Description Default <code>director_recon</code> <code>DirectorField</code> <p>Reconstructed director.</p> required <code>director_gt</code> <code>DirectorField</code> <p>Ground truth director.</p> required <code>I_original</code> <code>Optional[Dict[float, ndarray]]</code> <p>Original FCPM intensities.</p> <code>None</code> <code>I_reconstructed</code> <code>Optional[Dict[float, ndarray]]</code> <p>Reconstructed intensities.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary of statistics.</p>"}]}