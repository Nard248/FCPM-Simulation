"""
Numba-accelerated kernels for simulated annealing.

If numba is not installed, provides pure-Python fallbacks so the rest
of the code can import unconditionally.

Usage::

    from ._numba_kernels import sa_compute_delta_energy, sa_metropolis_sweep

These will be JIT-compiled on first call when numba is available.
"""

from __future__ import annotations

import numpy as np

try:
    from numba import njit

    @njit(cache=True)
    def sa_compute_delta_energy(n, y, x, z):
        """Compute energy change from flipping sign at (y, x, z).

        delta_E = sum_neighbors 4 * (n_i . n_j)

        JIT-compiled for O(1) per voxel.
        """
        ny, nx_dim, nz = n.shape[0], n.shape[1], n.shape[2]
        n_i = n[y, x, z]
        delta = 0.0

        neighbors = (
            (y - 1, x, z), (y + 1, x, z),
            (y, x - 1, z), (y, x + 1, z),
            (y, x, z - 1), (y, x, z + 1),
        )

        for idx in range(6):
            ny_idx, nx_idx, nz_idx = neighbors[idx]
            if 0 <= ny_idx < ny and 0 <= nx_idx < nx_dim and 0 <= nz_idx < nz:
                n_j = n[ny_idx, nx_idx, nz_idx]
                for c in range(3):
                    delta += 4.0 * n_i[c] * n_j[c]
        return delta

    @njit(cache=True)
    def sa_metropolis_sweep(n, temperature, rng_state):
        """Perform one full sweep of Metropolis updates.

        Each voxel is visited once in raster order.  Returns
        (total_flips, energy_change).

        ``rng_state`` is a flat array of random floats (length = n_voxels)
        pre-generated by the caller.
        """
        ny, nx_dim, nz = n.shape[0], n.shape[1], n.shape[2]
        total_flips = 0
        total_delta = 0.0
        idx = 0

        for y in range(ny):
            for x in range(nx_dim):
                for z in range(nz):
                    delta = sa_compute_delta_energy(n, y, x, z)

                    accept = False
                    if delta <= 0.0:
                        accept = True
                    elif temperature > 0.0 and rng_state[idx] < np.exp(-delta / temperature):
                        accept = True

                    if accept:
                        for c in range(3):
                            n[y, x, z, c] = -n[y, x, z, c]
                        total_flips += 1
                        total_delta += delta

                    idx += 1

        return total_flips, total_delta

    NUMBA_AVAILABLE = True

except ImportError:
    # Pure-Python fallbacks (same signatures)
    NUMBA_AVAILABLE = False

    def sa_compute_delta_energy(n, y, x, z):
        ny, nx_dim, nz = n.shape[:3]
        n_i = n[y, x, z]
        delta = 0.0
        neighbors = [
            (y - 1, x, z), (y + 1, x, z),
            (y, x - 1, z), (y, x + 1, z),
            (y, x, z - 1), (y, x, z + 1),
        ]
        for ny_idx, nx_idx, nz_idx in neighbors:
            if 0 <= ny_idx < ny and 0 <= nx_idx < nx_dim and 0 <= nz_idx < nz:
                delta += 4.0 * np.dot(n_i, n[ny_idx, nx_idx, nz_idx])
        return delta

    def sa_metropolis_sweep(n, temperature, rng_state):
        ny, nx_dim, nz = n.shape[:3]
        total_flips = 0
        total_delta = 0.0
        idx = 0
        for y in range(ny):
            for x in range(nx_dim):
                for z in range(nz):
                    delta = sa_compute_delta_energy(n, y, x, z)
                    accept = False
                    if delta <= 0.0:
                        accept = True
                    elif temperature > 0.0 and rng_state[idx] < np.exp(-delta / temperature):
                        accept = True
                    if accept:
                        n[y, x, z] = -n[y, x, z]
                        total_flips += 1
                        total_delta += delta
                    idx += 1
        return total_flips, total_delta


__all__ = [
    "NUMBA_AVAILABLE",
    "sa_compute_delta_energy",
    "sa_metropolis_sweep",
]
